<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eeymoo&#39; BLOG</title>
  
  
  <link href="https://blog.eeymoo.com/atom.xml" rel="self"/>
  
  <link href="https://blog.eeymoo.com/"/>
  <updated>2026-01-12T02:40:01.567Z</updated>
  <id>https://blog.eeymoo.com/</id>
  
  <author>
    <name>Eeymoo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2026 年最新！Obsidian + Github Pages + Github Actions 自动化部署博客全攻略</title>
    <link href="https://blog.eeymoo.com/blog/6231fe83919e.html"/>
    <id>https://blog.eeymoo.com/blog/6231fe83919e.html</id>
    <published>2026-01-06T03:54:34.000Z</published>
    <updated>2026-01-06T03:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 2023 年的时候我写了一篇[[Obsidian + Hexo + Github Pages + Github Actions 自动化部署博客]] 的文章，里面介绍了一下利用 Github Actions + Obsidian 进行静态博客部署的文章，现在看来存在很多的问题，比如说在 Obsidian 仓库的 Acitons 比较复杂，于是修改一下逻辑，将主要的 Actions 放到了 hexo-template 仓库，从而如果出现模板仓库需要更换、迭代、大修时，只需更换新的仓库，以及新的仓库即可，甚至不需要修改 Obsidian 中的 Acitons，对原本的架构进行了解耦。</p><p>将部署相关的内容完全存储在部署模板仓库，在部署模板仓库编译完成后，直接推送到Pages 仓库，具体逻辑如下图：</p><pre class="mermaid">sequenceDiagram# 明确标注3个独立仓库 + 本地电脑 + Pages服务participant Local as 本地电脑participant Repo1 as 仓库1：Obsidian笔记仓库(仅存.md)participant Repo2 as 仓库2：部署模板仓库(仅存Actions脚本)participant Repo3 as 仓库3：Pages静态文件仓库(仅存.html)participant Pages as GitHub Pages服务(指向Repo3)# 可选触发：本地推送笔记才执行后续流程opt 本地推送Obsidian笔记触发部署    Local->>Repo1: git push 推送修改后的.md笔记    # 跨仓库触发：笔记仓库调用部署仓库的Actions    Repo1->>Repo2: 触发 repository_dispatch 事件（obsidian-content-update）    # 激活部署仓库，开始执行部署脚本    activate Repo2        Repo2->>Repo1: git pull 拉取Repo1最新的.md笔记        Repo2->>Repo2: 执行脚本，将.md转换为.html静态文件        Repo2->>Repo3: git push 推送生成的.html到Repo3的main/gh-pages分支        # Pages服务监听Repo3的指定分支，更新后自动发布        Repo3->>Pages: 分支内容更新，触发Pages服务同步        Pages->>Pages: 加载Repo3的.html文件，对外发布可访问的网页    # 部署完成，停用部署仓库的执行状态    deactivate Repo2end</pre><p>在这次改造后，如果切换部署相关内容模板，可以修改部署模板，如果仓库名不进行改变的话甚至可以不修改 Obsidian 仓库，只修改 模板仓库即可。</p><p>我 Obsidian 仓库的 Github Actions 只做了最基础的触发功能。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">trigger-hexo-build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Obsidian内容变更时，触发Hexo模板仓库的主流程</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">push:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">&#x27;博客/**&#x27;</span> <span class="comment"># 仅监控博客内容目录变更</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">HEXO_TEMPLATE_REPO:</span> <span class="string">Eeymoo/obsidian2hexo-template</span> <span class="comment"># Hexo模板仓库</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">trigger-hexo:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Trigger</span> <span class="string">Hexo</span> <span class="string">Template</span> <span class="string">Build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">uses:</span> <span class="string">peter-evans/repository-dispatch@v3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">with:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVICE_ACCOUNT_KEY</span> <span class="string">&#125;&#125;</span> <span class="comment"># 有触发权限的密钥</span></span><br><span class="line"></span><br><span class="line"><span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.HEXO_TEMPLATE_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">event-type:</span> <span class="string">obsidian-content-update</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传递触发信息（便于调试）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">client-payload:</span> <span class="string">|</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="attr">&quot;obsidian_ref&quot;:</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; github.ref &#125;&#125;</span>&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="attr">&quot;obsidian_sha&quot;:</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; github.sha &#125;&#125;</span>&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="attr">&quot;triggered_by&quot;:</span> <span class="string">&quot;Obsidian content update&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体部署功能实在 <a href="https://github.com/Eeymoo/obsidian2hexo-template">部署仓库</a> 中，当前是 Hexo ，后续我可能会使用其他支持 <strong>mdx</strong> 的静态部署功能。</p><p>这样就见我我们的 Obsidian 仓库与部署仓库隔离，可以将 Obsidian 仓库隐藏，保持可以保证一定的信息隔离，当然数据联网就不是绝对安全的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 2023 年的时候我写了一篇[[Obsidian + Hexo + Github Pages + Github Actions 自动化部署博客]] 的文章，里面介绍了一下利用 Github Actions + Obsidian 进行静态博客部署的文章，现在看来存在很多的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数组交集判断的性能优化：从双循环到双指针的多种方法</title>
    <link href="https://blog.eeymoo.com/post/shu-zu-shi-fou-cun-zai-jiao-ji-de-xing-neng-you-hua-wen-ti-z1kwfix.html"/>
    <id>https://blog.eeymoo.com/post/shu-zu-shi-fou-cun-zai-jiao-ji-de-xing-neng-you-hua-wen-ti-z1kwfix.html</id>
    <published>2024-12-31T16:47:50.000Z</published>
    <updated>2024-12-31T16:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组是否存在交集的性能优化问题"><a href="#数组是否存在交集的性能优化问题" class="headerlink" title="数组是否存在交集的性能优化问题"></a>数组是否存在交集的性能优化问题</h1><blockquote><p>本文使用 <code>gpt-3.5-turbo</code>​ 协助完成。</p></blockquote><p>在项目中出现一个这样的权限判断逻辑，存在两个数组，一个是后端返回的所有权限数组，另一个是前端代码中存在的按钮权限数组，我们要判断这两个数组是否存在交集合，如果存在交集就说明具备这个按钮的权限，这个按钮就可以展示。</p><p>遇到数组交集的判断存在几种复杂或者简单的思路，一种是硬计算，使用双 for 循环判断，但是这种方式无疑是时间复杂度最大的，也可以使用数组的高阶函数进行判断，这两种时间复杂度相对较高，也可以使用 <code>Set.has()</code>​ 进行判断，但是不知道时间复杂度是否会将度，不过这无可厚非，这也是一种简单的写法，最起码代码便简单了，看起来更舒服，当然也存在一些高阶算法写法，比如双指针算法，会极大程度降低时间复杂度，不过暂时不考虑。</p><h2 id="双-For-循环硬计算"><a href="#双-For-循环硬计算" class="headerlink" title="双 For 循环硬计算"></a>双 For 循环硬计算</h2><p>我们已知双 For 循环的时间复杂度是 O(n * m)，这里的 n 和 m 分别是两个数组的长度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasIntersection (arr1, arr2) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.<span class="property">length</span>; i++) &#123; <span class="comment">// 遍历第一个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr2.<span class="property">length</span>; j++) &#123; <span class="comment">// 遍历第二个数组</span></span><br><span class="line">            <span class="keyword">if</span> (arr1[i] === arr2[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-some​-和-includes​"><a href="#使用-some​-和-includes​" class="headerlink" title="使用 some​ 和 includes​"></a>使用 <code>some</code>​ 和 <code>includes</code>​</h2><p>我们可以使用 <code>some</code>​ 和 <code>includes</code>​ 优化代码，时间复杂度同上，但是代码更加简洁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasIntersection (arr1, arr2) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> arr.<span class="title function_">some</span>(</span><br><span class="line"><span class="function"><span class="params">item</span> =&gt;</span> arr2.<span class="title function_">includes</span>(item)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Set-has​-和-some​"><a href="#使用-Set-has​-和-some​" class="headerlink" title="使用 Set.has​ 和 some​"></a>使用 <code>Set.has</code>​ 和 <code>some</code>​</h2><p>当然我们也可使用 <code>Set.has</code>​ 来代替 <code>includes</code>​，而且 <code>Set.has</code>​ 的时间复杂度更低。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">‍<span class="keyword">const</span> hasIntersection (arr1, arr2) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr1);</span><br><span class="line"><span class="keyword">return</span> arr.<span class="title function_">some</span>(</span><br><span class="line"><span class="function"><span class="params">item</span> =&gt;</span> set.<span class="title function_">has</span>(item)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然在考虑 <code>includes</code>​ 和 <code>Set.has</code>​ 复杂度的时候也要考虑其他内容，比如说数据集的大小，内容重复度之类，这里不做考虑，不过可以研究，详见参考内容。</p><h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><p>在极端优化情况下可以使用双指针算法解决这类问题，当然在日常开发中，通常使用上述方法就可以解决问题，简单相对高效，没必要求极端性能，不过这里也给出极端思路解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先如果使用双指针算法解决这个问题首先要对内容进行排序，排序也要使用算法排序</span></span><br><span class="line"><span class="comment">// 我们这里不考虑排序算法，并且假定内容为数字</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">hasIntersection</span> = (<span class="params">arr1, arr2</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">let</span> sortArr1 = <span class="title function_">sort</span>(arr1);</span><br><span class="line"><span class="keyword">let</span> sortArr2 = <span class="title function_">sort</span>(arr2);</span><br><span class="line"><span class="keyword">let</span> current1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> current2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (current1 &lt; sortArr1.<span class="property">length</span> &amp;&amp; current2 &lt; sortArr2.<span class="property">length</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (sortArr1[current1] &lt; sortArr2[current2]) &#123;</span><br><span class="line">current1 ++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sortArr1[current1] &gt; sortArr2[current2]) &#123;</span><br><span class="line">current2 ++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sort</span> = (<span class="params">arr</span>) =&gt; arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>];</span><br><span class="line"><span class="keyword">const</span> nums2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasIntersection</span>(nums1, nums2));</span><br></pre></td></tr></table></figure><p>在实际解决问题中要是用开发时间短，性能较好的内容，没必要使用性能特别好，但是开发时间较长的内容（特殊行业除外），我们要结合项目的实际需要实现这样的功能，开发也是妥协的艺术，做开发时间和性能的妥协。</p><p>‍</p><p>参考文献：</p><ol><li><a href="https://blog.csdn.net/qq_41865545/article/details/143502905">性能对比：为什么 Set.has() 比 Array.includes() 更快？</a></li></ol>]]></content>
    
    
    <summary type="html">本文讨论了在权限判断逻辑中，如何优化判断两个数组是否存在交集的方法。首先介绍了双 For 循环的硬计算方法，时间复杂度为 O(n * m)，在性能上较低效。接着，通过使用 `some` 和 `includes` 方法优化了代码，尽管时间复杂度未变，但可读性更好。进一步采用 `Set.has()` 替代 `includes` 提高了效率，因其时间复杂度更低。

此外，介绍了使用双指针算法进行极端优化的思路，但需要对数组进行排序，虽然可能在性能上更优，但开发时间较长。在实际开发时，应根据项目需求平衡开发时间与性能优化，选择合适的方法进行实现。最后，文章提及了参考文献，解释了 `Set.has()` 比 `Array.includes()` 更快的原因。</summary>
    
    
    
    <category term="JavaScript" scheme="https://blog.eeymoo.com/categories/JavaScript/"/>
    
    
    <category term="性能优化" scheme="https://blog.eeymoo.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="开发技巧" scheme="https://blog.eeymoo.com/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>研究数组迭代方法：稀疏数组处理、多种遍历方式</title>
    <link href="https://blog.eeymoo.com/post/research-on-array-iteration-methods-hev8j.html"/>
    <id>https://blog.eeymoo.com/post/research-on-array-iteration-methods-hev8j.html</id>
    <published>2024-12-31T14:21:53.000Z</published>
    <updated>2024-12-31T14:21:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组迭代方法的研究"><a href="#数组迭代方法的研究" class="headerlink" title="数组迭代方法的研究"></a>数组迭代方法的研究</h1><p>我们知道数组存在一些迭代方法将会遍历数组，在这篇文章中主要研究一些这些方法的相关问题，比如说<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84">稀疏数组</a>处理方法、如何打断、方法内异常处理等等。</p><h3 id="稀疏数组处理方法"><a href="#稀疏数组处理方法" class="headerlink" title="稀疏数组处理方法"></a>稀疏数组处理方法</h3><p>不同的迭代方法在处理稀疏数组的时候存在不同的方式，在 MDN 中指出，在旧的迭代方法中<strong>处理空槽的方式与处理包含</strong> <strong>​<code>undefined</code>​</strong>​ <strong>索引的方式不同</strong>，而在新的迭代方法中<strong>不会对空槽进行特殊处理，而是将它们视为包含</strong> <strong>​<code>undefined</code>​</strong>​。</p><p>在旧的方法中对空槽的方式是  “诸如 <strong>​<code>forEach</code>​</strong>​ 之类的迭代方法根本不会访问空槽。其他方法，如<strong>​<code>concat</code>​</strong>​ <strong>、​</strong>​**<code>copyWithin</code>​​** 等，在进行复制时会保留空槽，因此最终数组依然是稀疏的。”</p><p>以下数组对数组进行了特殊处理 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat"><code>concat()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin"><code>copyWithin()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every"><code>every()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"><code>filter()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat"><code>flat()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap"><code>flatMap()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"><code>forEach()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf"><code>indexOf()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf"><code>lastIndexOf()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>map()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce"><code>reduce()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight"><code>reduceRight()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse"><code>reverse()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice"><code>slice()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some"><code>some()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort"><code>sort()</code></a>​ 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice"><code>splice()</code></a>​。</p><p>不对空槽进行特殊处理的方法，将其视为 <code>undifined</code> ​的方法有：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries"><code>entries()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill"><code>fill()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find"><code>find()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex"><code>findIndex()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findLast"><code>findLast()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findLastIndex"><code>findLastIndex()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes"><code>includes()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join"><code>join()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys"><code>keys()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString"><code>toLocaleString()</code></a>​、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values"><code>values()</code></a>​ 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/with"><code>with()</code></a>​。</p><p><strong>引用</strong></p><ol start="0"><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%92%8C%E7%A9%BA%E6%A7%BD">MDN - 数组方法和空槽</a></li></ol><h3 id="数组迭代方法的打断方式"><a href="#数组迭代方法的打断方式" class="headerlink" title="数组迭代方法的打断方式"></a>数组迭代方法的打断方式</h3><blockquote><p><strong>如果需要在数组迭代时需要灵活的中断迭代，通常建议使用传统的</strong> <strong>​<code>for</code>​</strong>​<strong>循环或</strong> <strong>​<code>for...of</code>​</strong>​<strong>循环，这样可以更直接地使用</strong> <strong>​<code>break</code>​</strong>​<strong>来中断循环。</strong></p></blockquote><p>当然我们也可以研究一些常见方法的打断方式，比如说，我们在方法外设置一个变量 <code>isBreak</code> ​作为判断是否是否需要打断的依据，在需要打断的地方将 isBreak 设置为 true，当然我们需要在方法的前面放一段特殊的代码。整体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isBreak;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, idnex</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(idnex === <span class="number">0</span>)&#123;</span><br><span class="line">        isBreak = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isBreak)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">    <span class="keyword">if</span>(item === <span class="number">3</span>) &#123;</span><br><span class="line">        isBreak = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>isBreak</code>​ 用于控制循环是否继续。当遇到 <code>item === 3</code>​ 时，我们将 <code>isBreak</code>​ 设置为 <code>true</code>​，从而在下次迭代时跳过后续的逻辑。</p><p>当然也有一些方法自带打断，例如：</p><ol><li>some 会在存在一个元素符合测试函数时，停止遍历，并且返回 true；</li><li>every 会在存在一个元素不符合测试函数是，停止遍历，并且返回 false；</li><li>find 和 findIndex 会在找到第一个符合的元素时，停止遍历，并且返回值或者索引；</li></ol><h2 id="数组迭代方法的异常处理"><a href="#数组迭代方法的异常处理" class="headerlink" title="数组迭代方法的异常处理"></a>数组迭代方法的异常处理</h2><p>在数组迭代方法的异常处理中通常需要思考的问题主要是，出现异常是否继续执行接下来的迭代，如果需要执行接下来的迭代通常是将 try-catch 防止方法内，如果出现了异常将不需要迭代剩下的元素，就需要将 try-catch 放在方法外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something went wrong!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Error processing item <span class="subst">$&#123;item&#125;</span>: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Error processing item 3: Something went wrong!</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，假设在 <code>item===3</code> 的时候出现了一个不是很严重的问题，后续代码可以继续执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something went wrong!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Iteration stopped due to error: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Iteration stopped due to error: Something went wrong</span></span><br></pre></td></tr></table></figure><p>‍</p>]]></content>
    
    
    <summary type="html">本文探讨了数组的不同迭代方法及其在处理稀疏数组时的表现。稀疏数组中存在空槽，而不同的迭代方法对待这些空槽的方式各异。根据 MDN 的说明，旧的迭代方法如 `forEach` 不会访问空槽，而其他方法（如 `concat`、`copyWithin` 等）在复制时会保留这些空槽，因此最终数组仍为稀疏状态。相对地，新的迭代方法则将空槽视为包含 `undefined`。文章列举了处理空槽和不对空槽进行特殊处理的常用数组方法，并总结了各自的特性，强调了在使用迭代方法时需要了解其对稀疏数组的行为，以便做出合适的选择。</summary>
    
    
    
    <category term="JavaScript" scheme="https://blog.eeymoo.com/categories/JavaScript/"/>
    
    
    <category term="数组" scheme="https://blog.eeymoo.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="迭代" scheme="https://blog.eeymoo.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
    <category term="稀疏" scheme="https://blog.eeymoo.com/tags/%E7%A8%80%E7%96%8F/"/>
    
    <category term="方法" scheme="https://blog.eeymoo.com/tags/%E6%96%B9%E6%B3%95/"/>
    
    <category term="异常处理" scheme="https://blog.eeymoo.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>探索 JavaScript Object 顺序：从迷惑到通透，一文读懂</title>
    <link href="https://blog.eeymoo.com/blog/f4a8e220f18b.html"/>
    <id>https://blog.eeymoo.com/blog/f4a8e220f18b.html</id>
    <published>2023-08-18T17:47:53.000Z</published>
    <updated>2023-08-18T17:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天的面试中出现了一个题目：</p><blockquote><p>将 对象 <code>&#123;6: 46, 8: 23, 14: 5, 10: 3&#125;</code> 按照值的顺序排列。</p></blockquote><p>由于做开始他说的一个数组，说这个题的时候我以为是类数组对象，结果是是如上的对象，排序嘛，（不考虑时间复杂度和空间复杂度的话）基本上没什么难度， 但是一直有一个疑惑在脑中，Object 不是无序的吗？</p><blockquote><p>本文主要探讨不同的 <em>Object</em> 定义方式（或者说声明方式）是否影响”<em>Object</em> 顺序“，”<em>Object</em> 顺序“是什么样的，以及常见处理”Object顺序“的方式。</p></blockquote><p>首先再次之前我的认为是”对象是无序的，数组是有序的，如果处理对象的顺序的话，还是使用数组对象<code>[&#123;key, value&#125;]</code>的方式“ 。</p><p>在 <a href="https://www.ecma-international.org/wp-content/uploads/ECMA-262_3rd_edition_december_1999.pdf">ECMA-262_3rd_edition_december_1999</a> 中有提到：</p><blockquote><p>4.3.3 Object<br>An <strong>object</strong> is a member of the type <strong>Object</strong>. It is an unordered collection of properties each of which contains a primitive value, object, or function. A function stored in a property of an object is called a method.</p></blockquote><p>也就是在 ES3 中是 Objiect 是乱序的，但是在 ES6 中逐渐开始在 Object 的中开始添加 Object 部分放的顺序之说。</p><p>不同浏览器在处理 <code>for...in</code> 时的解析顺序时不同的，在 Chrome 和 Opera 中遵循的是 <strong>ECMA-262</strong> 第五版本规范，而在 Firefox 和 Safari遵循的是 <strong>ECMA-262</strong>  第三版本规范。</p><p>在通常情况下，如果要处理对象的排序，我建议使用数组处理，也就是将对象处理为 <code>[&#123; key, value &#125;]</code> 这样的的数组形式，按照数组排序，因为我还是觉得对象是无序的，尽管他是按照一定的顺序排序的，但为了避免在不同的浏览器中的排序不同还是将他作为数组处理比较好。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://jartto.wang/2016/10/25/does-js-guarantee-object-property-order/">js能够保证object属性的输出顺序吗？ - Jartto’s blog</a></li><li><a href="https://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order">Does JavaScript guarantee object property order? - Stack Overflow</a></li><li><a href="https://www.ecma-international.org/wp-content/uploads/ECMA-262_3rd_edition_december_1999.pdf">ECMA-262_3rd_edition_december_1999</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天的面试中出现了一个题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将 对象 &lt;code&gt;&amp;#123;6: 46, 8: 23, 14: 5, 10: 3&amp;#125;&lt;/code&gt; 按照值的顺序排列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于做开始他说的一个数组，说</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Obsidian + Hexo + Github Pages + Github Actions 自动化部署博客</title>
    <link href="https://blog.eeymoo.com/blog/a871698f1912.html"/>
    <id>https://blog.eeymoo.com/blog/a871698f1912.html</id>
    <published>2023-07-29T12:43:27.000Z</published>
    <updated>2023-07-29T12:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>当前网页使用 Obsidian 作为编辑器以及知识库，Hexo 作为静态博客框架，也、就是将markdown文档转换为静态 html ，放在 Github 并且部署 Github Pages 上的。</p><p>个人需需要将 Obsidian 的 markdown 文档放置在一个私有仓库，将 Hexo Template 放置在共有仓库，github pages 也放在另一个仓库，当然 Hexo Template 可以和 Github Pages 放在相同的仓库中，如果Hexo Template也需要分离的话在将其分离。</p><p>静态博客框架仓库和部署仓库分离的好处是如果更换静态博客框架例如Gatsby，VuePress的话，可以不需要修改部署仓库只需要新建新的静态博客框架仓库，调整Obsidian 仓库的 Actions 就可以。</p><p>分离的坏处就是需要有一个额外的仓库管理静态博客框架，当然个人觉得好处大于坏处。</p><p>在 Obsidian 仓库，和 Hexo 仓库分别设置了两个 Actions，Obsidian 的仓库 Actions 是主 Actions，Hexo 的 Actions 只是为了触发主 Actions。</p><p>也可以将主 Actions 放在 Hexo 上，甚至应该放到静态博客框架仓库里面，如果要更换静态博客框架，肯定需要重新修改主 Actions ，而且是大幅修改，而 Obsidian Actions 只需要修改触发的主 Actions 就可以，减少了不必要的 Obsidian 仓库的变动，如果没有仓库洁癖这些问题都是小问题。</p><p>本网站的部署 Actions 整体思路大致如下（ Local 代表本地仓库）：</p><pre class="mermaid">sequenceDiagramparticipant Local as Localparticipant Obsidian as Obsidianparticipant Hexo as Hexo Templateparticipant Github as Github Pagesopt 推送 Obsidian 触发    Local->>Obsidian:推送    Obsidian->>Obsidian: 触发endopt 推送 Hexo template 触发    Local->>Hexo: 推送    par Hexo Actions    Hexo->>Obsidian: 触发    endendpar Obsidian ActionsHexo->>Obsidian: 拉取Obsidian->>Obsidian:生成静态文件Obsidian->>Github:推送end</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当前网页使用 Obsidian 作为编辑器以及知识库，Hexo 作为静态博客框架，也、就是将markdown文档转换为静态 html ，放在 Github 并且部署 Github Pages 上的。&lt;/p&gt;
&lt;p&gt;个人需需要将 Obsidian 的 markdown 文档放</summary>
      
    
    
    
    <category term="DevOps" scheme="https://blog.eeymoo.com/categories/DevOps/"/>
    
    
    <category term="DevOps" scheme="https://blog.eeymoo.com/tags/DevOps/"/>
    
    <category term="Github Actions" scheme="https://blog.eeymoo.com/tags/Github-Actions/"/>
    
  </entry>
  
  <entry>
    <title>一文说透！CSS 选择器优先级计算规则大揭秘</title>
    <link href="https://blog.eeymoo.com/blog/61b7ac3ee9e9.html"/>
    <id>https://blog.eeymoo.com/blog/61b7ac3ee9e9.html</id>
    <published>2022-05-31T19:39:00.000Z</published>
    <updated>2022-05-31T19:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS优先级是一个值得思考的问题，再次之前我对CSS优先级的理解是:</p><blockquote><p>!important&gt;内联样式&gt;ID选择器&gt;类选择器&gt;类型选择器</p></blockquote><p>相信很多人对CSS优先级的理解也是这样的，但是一篇文章(<a href="http://c.biancheng.net/view/7216.html">CSS选择器的优先级（精讲版） (biancheng.net)</a>)上面书写了关于<strong>CSS 选择器优先级的计算规则</strong>的内容，使我开始对CSS优先级进行重新研究。</p><p>根据W3C给出关于选择器特异性(specificity，国内一般称优先级)的解释，选择器分为ABC三个等级，其中A为ID选择器，B包括类选择器、属性选择器和伪类，C包括类型选择器和伪元素，当然还存在一个通用选择器，但是通用选择器一般忽略。</p><table><thead><tr><th>等级</th><th>包含选择器</th></tr></thead><tbody><tr><td>A</td><td>计算选择器中 ID 选择器的数量</td></tr><tr><td>B</td><td>计算选择器中类选择器、属性选择器和伪类的数量</td></tr><tr><td>C</td><td>计算选择器中类型选择器和伪元素的数量</td></tr></tbody></table><p>优先级的计算，从A级开始到C级结束，如果到C级是两个选择器的优先级还是相等的那么有限选择靠后的选择器。</p><h3 id="重复简单选择器"><a href="#重复简单选择器" class="headerlink" title="重复简单选择器"></a>重复简单选择器</h3><p>CSS选择器允许重复出现简单选择器，并且简单选择器的重复出现会增加优先级。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span><span class="selector-class">.class</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.class</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说如上代码中第一个选择器重复出现了<code>.class</code>选择器，第二个选择器只出现了一个<code>.class</code>选择器，这两种写法都是正确的，并且第一个选择器<code>.class.class</code>的优先级大于第二个选择器<code>.class</code>，所以结果是背景颜色将呈现红色。</p><table><thead><tr><th>选择器</th><th>优先级 (A, B, C)</th></tr></thead><tbody><tr><td>.class.class</td><td>(0, 2, 0)</td></tr><tr><td>.class</td><td>(0, 1, 0)</td></tr></tbody></table><blockquote><p>在低版本CSS中可能简单重复选择器会被忽略，如在ie8中重复id或被忽略，在ie5中重复的class或被忽略。</p><p>拒绝IE，从我做起！</p></blockquote><h3 id="特殊选择器"><a href="#特殊选择器" class="headerlink" title="特殊选择器"></a>特殊选择器</h3><p>一些伪类和其他选择器中存在一些特殊的选择器，因此单独定义了这些特殊选择器的特异性。</p><ol><li>选择器<code>:is()</code>、<code>:not()</code>、<code>:has()</code>的优先级是选择器列表中最具有复杂性的选择器的优先级取代。</li><li>选择器<code>:nth-child()</code>、<code>:nth-last-child()</code>的优先级是伪类本身的优先级（计为一个伪类选择器，也就是计为B），再加上选择器列表中最具复杂性的选择器的优先级。</li><li>选择器<code>:where()</code>伪类的优先级被零代替，也就是没有优先级，再优先级计算中不做数。</li><li>通用选择符以及其他选择符在优先级中不计数。</li></ol><h3 id="优先级计算"><a href="#优先级计算" class="headerlink" title="优先级计算"></a>优先级计算</h3><table><thead><tr><th>选择器</th><th>优先级 (A, B, C)</th></tr></thead><tbody><tr><td>.class</td><td>(0, 1, 0)</td></tr><tr><td>#Red</td><td>(1, 0, 0)</td></tr><tr><td>.container :is(.container&gt;#Red, .container&gt;.class)</td><td>(1, 2, 0)</td></tr><tr><td>.container #Red.class:nth-child(1)</td><td>(1, 3, 0)</td></tr><tr><td>:is(.container&gt;.class.class)</td><td>(0, 3, 0)</td></tr><tr><td>#Red:is(.container&gt;.class)</td><td>(1, 2, 0)</td></tr><tr><td>.container div:nth-child(1)</td><td>(0, 2, 1)</td></tr><tr><td>:is(#Red.class)</td><td>(1, 1, 0)</td></tr><tr><td>#Red.class</td><td>(1, 1, 0)</td></tr><tr><td>#Red.class:nth-child(1)</td><td>(1, 2, 0)</td></tr><tr><td>#Red#Red</td><td>(2, 0, 0)</td></tr></tbody></table><p><a href="https://code.juejin.cn/pen/7103862825264611359">代码片段</a></p><p><a href="https://codepen.io/onemue/pen/RwQMBmd">codepen</a></p><h3 id="specificity求和"><a href="#specificity求和" class="headerlink" title="specificity求和"></a>specificity求和</h3><p>在一些其他文档中将讲A、B、C分别比作100,10,1 进行求和，是不准确的，如果按照这样做那么10个class是不是相当于一个id，显然不是。</p><p>在<a href="https://www.w3.org/TR/CSS1/#cascading-order">CSS Level 1</a>、<a href="https://drafts.csswg.org/selectors-3/#specificity">Selectors Level 3</a>中也有这样的描述。</p><p>在主流浏览器中高等级高于低等级是即使ABC求和相同也不会优先使用后声明的CSS。</p><p>造成这样的原因是<strong>权重的进制是并不是十进制，CSS 权重进制在 IE6 为 256，后来扩大到了 65536，现代浏览器则采用更大的数量</strong>。也可以理解<strong>选择器的权值不能进位</strong>，或者理解为选择器权值ABC单独计算比较。</p><h3 id="关于-important"><a href="#关于-important" class="headerlink" title="关于!important "></a>关于<code>!important </code></h3><p>MDN指出“使用 <code>!important</code> 是一个<strong>坏习惯</strong>，应该尽量避免”，并给出了使用<code>!important</code> 的情况：</p><ul><li><strong>一定</strong>要优先考虑使用样式规则的优先级来解决问题而不是 <code>!important</code></li><li><strong>只有</strong>在需要覆盖全站或外部 CSS 的特定页面中使用 <code>!important</code></li><li><strong>永远不要</strong>在你的插件中使用 <code>!important</code></li><li><strong>永远不要</strong>在全站范围的 CSS 代码中使用 <code>!important</code></li></ul><p>以及替代 <code>!important</code>的方法:</p><ol><li>更好地利用 CSS 级联属性</li><li>使用更具体的规则。在您选择的元素之前，增加一个或多个其他元素，使选择器变得更加具体，并获得更高的优先级。</li><li>对于（2）的一种特殊情况，当您无其他要指定的内容时，请复制简单的选择器以增加特异性。</li></ol><p>推荐阅读<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity#!important_%E4%BE%8B%E5%A4%96%E8%A7%84%E5%88%99">优先级 - CSS（层叠样式表） | MDN (mozilla.org)</a>，了解更多<code>!important</code>的使用意见。</p><h3 id="其他-CSS-优先规则"><a href="#其他-CSS-优先规则" class="headerlink" title="其他 CSS 优先规则"></a>其他 CSS 优先规则</h3><p><strong>CSS 优先规则1：</strong> 最近的祖先样式比其他祖先样式优先级高。</p><p><strong>CSS 优先规则2：</strong> “直接样式”比”祖先样式”优先级高。</p><p><strong>CSS 优先规则3：</strong> 优先级关系：内联样式 &gt; ID 选择器 &gt; 类选择器 &#x3D; 属性选择器 &#x3D; 伪类选择器 &gt; 标签选择器 &#x3D; 伪元素选择器。</p><p><strong>CSS 优先规则4：</strong> 计算选择符中 ID 选择器的个数（a），计算选择符中类选择器、属性选择器以及伪类选择器的个数之和（b），计算选择符中标签选择器和伪元素选择器的个数之和（c）。按 a、b、c 的顺序依次比较大小，大的则优先级高，相等则比较下一个。若最后两个的选择符中 a、b、c 都相等，则按照”就近原则”来判断。</p><p><strong>CSS 优先规则5：</strong> 属性后插有 <strong>!important</strong> 的属性拥有最高优先级。若同时插有 <strong>!important</strong>，则再利用规则 3、4 判断优先级。</p><blockquote><p>注意: 文档树中元素的接近度（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity#%E6%97%A0%E8%A7%86DOM%E6%A0%91%E4%B8%AD%E7%9A%84%E8%B7%9D%E7%A6%BB">Proximity of elements</a>）对优先级没有影响。</p></blockquote><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="http://www.w3.org/TR/selectors/#specificity">Selectors Level 4</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity">优先级 - CSS（层叠样式表） | MDN (mozilla.org)</a></li><li><a href="https://www.runoob.com/w3cnote/css-style-priority.html">CSS 样式优先级 | 菜鸟教程 (runoob.com)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CSS优先级是一个值得思考的问题，再次之前我对CSS优先级的理解是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;!important&amp;gt;内联样式&amp;gt;ID选择器&amp;gt;类选择器&amp;gt;类型选择器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信很多人对CSS优先级的理解也</summary>
      
    
    
    
    <category term="CSS" scheme="https://blog.eeymoo.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="https://blog.eeymoo.com/tags/CSS/"/>
    
    <category term="WEB 标准" scheme="https://blog.eeymoo.com/tags/WEB-%E6%A0%87%E5%87%86/"/>
    
  </entry>
  
</feed>