[
  {
    "id": "blog:shu-zu-shi-fou-cun-zai-jiao-ji-de-xing-neng-you-hua-wen-ti-z1kwfix",
    "type": "blog",
    "content": "数组是否存在交集的性能优化问题\n\n本文使用 ​ 协助完成。\n\n在项目中出现一个这样的权限判断逻辑，存在两个数组，一个是后端返回的所有权限数组，另一个是前端代码中存在的按钮权限数组，我们要判断这两个数组是否存在交集合，如果存在交集就说明具备这个按钮的权限，这个按钮就可以展示。\n\n遇到数组交集的判断存在几种复杂或者简单的思路，一种是硬计算，使用双 for 循环判断，但是这种方式无疑是时间复杂度最大的，也可以使用数组的高阶函数进行判断，这两种时间复杂度相对较高，也可以使用 ​ 进行判断，但是不知道时间复杂度是否会将度，不过这无可厚非，这也是一种简单的写法，最起码代码便简单了，看起来更舒服，当然也存在一些高阶算法写法，比如双指针算法，会极大程度降低时间复杂度，不过暂时不考虑。\n\n双 For 循环硬计算\n\n我们已知双 For 循环的时间复杂度是 O(n * m)，这里的 n 和 m 分别是两个数组的长度。\n\n使用 ​ 和 ​\n\n我们可以使用 ​ 和 ​ 优化代码，时间复杂度同上，但是代码更加简洁。\n\n使用 ​ 和 ​\n\n当然我们也可使用 ​ 来代替 ​，而且 ​ 的时间复杂度更低。\n\n当然在考虑 ​ 和 ​ 复杂度的时候也要考虑其他内容，比如说数据集的大小，内容重复度之类，这里不做考虑，不过可以研究，详见参考内容。\n\n双指针算法\n\n在极端优化情况下可以使用双指针算法解决这类问题，当然在日常开发中，通常使用上述方法就可以解决问题，简单相对高效，没必要求极端性能，不过这里也给出极端思路解决。\n\n在实际解决问题中要是用开发时间短，性能较好的内容，没必要使用性能特别好，但是开发时间较长的内容（特殊行业除外），我们要结合项目的实际需要实现这样的功能，开发也是妥协的艺术，做开发时间和性能的妥协。\n\n‍\n\n参考文献：\n性能对比：为什么 Set.has() 比 Array.includes() 更快？",
    "date": "2024-12-31 16:47:50"
  },
  {
    "id": "blog:shu-zu-shi-fou-cun-zai-jiao-ji-de-xing-neng-you-hua-wen-ti-z1kwfix",
    "type": "blog",
    "content": "数组是否存在交集的性能优化问题\n\n本文使用 ​ 协助完成。\n\n在项目中出现一个这样的权限判断逻辑，存在两个数组，一个是后端返回的所有权限数组，另一个是前端代码中存在的按钮权限数组，我们要判断这两个数组是否存在交集合，如果存在交集就说明具备这个按钮的权限，这个按钮就可以展示。\n\n遇到数组交集的判断存在几种复杂或者简单的思路，一种是硬计算，使用双 for 循环判断，但是这种方式无疑是时间复杂度最大的，也可以使用数组的高阶函数进行判断，这两种时间复杂度相对较高，也可以使用 ​ 进行判断，但是不知道时间复杂度是否会将度，不过这无可厚非，这也是一种简单的写法，最起码代码便简单了，看起来更舒服，当然也存在一些高阶算法写法，比如双指针算法，会极大程度降低时间复杂度，不过暂时不考虑。\n\n双 For 循环硬计算\n\n我们已知双 For 循环的时间复杂度是 O(n * m)，这里的 n 和 m 分别是两个数组的长度。\n\n使用 ​ 和 ​\n\n我们可以使用 ​ 和 ​ 优化代码，时间复杂度同上，但是代码更加简洁。\n\n使用 ​ 和 ​\n\n当然我们也可使用 ​ 来代替 ​，而且 ​ 的时间复杂度更低。\n\n当然在考虑 ​ 和 ​ 复杂度的时候也要考虑其他内容，比如说数据集的大小，内容重复度之类，这里不做考虑，不过可以研究，详见参考内容。\n\n双指针算法\n\n在极端优化情况下可以使用双指针算法解决这类问题，当然在日常开发中，通常使用上述方法就可以解决问题，简单相对高效，没必要求极端性能，不过这里也给出极端思路解决。\n\n在实际解决问题中要是用开发时间短，性能较好的内容，没必要使用性能特别好，但是开发时间较长的内容（特殊行业除外），我们要结合项目的实际需要实现这样的功能，开发也是妥协的艺术，做开发时间和性能的妥协。\n\n‍\n\n参考文献：\n性能对比：为什么 Set.has() 比 Array.includes() 更快？",
    "date": "2024-12-31 16:47:50"
  }
]