[
  {
    "id": "blog:obsidian-hexo-github-pages-github-actions-auto-deploy-blog",
    "type": "blog",
    "content": "当前网页使用 Obsidian 作为编辑器以及知识库，Hexo 作为静态博客框架，也、就是将markdown文档转换为静态 html ，放在 Github 并且部署 Github Pages 上的。\n\n个人需需要将 Obsidian 的 markdown 文档放置在一个私有仓库，将 Hexo Template 放置在共有仓库，github pages 也放在另一个仓库，当然 Hexo Template 可以和 Github Pages 放在相同的仓库中，如果Hexo Template也需要分离的话在将其分离。\n\n静态博客框架仓库和部署仓库分离的好处是如果更换静态博客框架例如Gatsby，VuePress的话，可以不需要修改部署仓库只需要新建新的静态博客框架仓库，调整Obsidian 仓库的 Actions 就可以。\n\n分离的坏处就是需要有一个额外的仓库管理静态博客框架，当然个人觉得好处大于坏处。\n\n在 Obsidian 仓库，和 Hexo 仓库分别设置了两个 Actions，Obsidian 的仓库 Actions 是主 Actions，Hexo 的 Actions 只是为了触发主 Actions。\n\n也可以将主 Actions 放在 Hexo 上，甚至应该放到静态博客框架仓库里面，如果要更换静态博客框架，肯定需要重新修改主 Actions ，而且是大幅修改，而 Obsidian Actions 只需要修改触发的主 Actions 就可以，减少了不必要的 Obsidian 仓库的变动，如果没有仓库洁癖这些问题都是小问题。\n\n本网站的部署 Actions 整体思路大致如下（ Local 代表本地仓库）：",
    "date": "2023-07-29 12:43:27"
  },
  {
    "id": "blog:设计模式-单例模式-使用闭包完成单例模式开发",
    "type": "blog",
    "content": "单例模式，也就是要确保在某一个类在全剧中只有一个实例，并且提供一个全局的访问点来访问这一实例。\n\n如何实现一个单例模式，主要讲究两个字，一个字“存”，在类内存在一个属性，如果这个属性不为空那么就初始化当前类赋值给这一属性，另一个字“堵”，将所有的可能再次实例化当前类的方法都“堵”住，并且返回“存”的实例，当然在第一个次实例的时候需要正常实例化，也就是存放实例的属性为空时，可以正常实例化。\n\n在前端开发中可以使用闭包实现单例模式（当然也可以使用 Class 语法糖或者构造函数形式实现），我们将设想一个案例：将一些配置内容或者一些其他内容放在一个单例中供其他内容访问。\n\n首先我们将通过闭包实现一个配置信息的管理，首先我们写一个简单的闭包代码，使  属性不受外部污染。\n\n但是我们要实现一个单例模式，就要在再次返回前做判断，如果没有  要对他进行“实例化“并返回，如果存在  就将cunfig返回。\n\n当然这就完成了一个简单的配置对象的单例，但是我们发现现在的  和直接返回一个对象没有什么区别，这是为什么？\n\n有了配置对象的单例，不对对象进行操作基本上没什么用，属于”为醋包饺“，不提倡。\n\n接下来我们将要实现的是，为配置对象新增  方法，这个方法将传入两个参数，分别是  和 ，作用就是将对象中的  的值改成  传入的内容。\n\n当然在前端中不可能是一个页面打开一直不关闭，所以我们就要对数据进行缓存，一下案例中使用了  和  对数据进行了处理，只能处理简单数据。 \n\ntodo 使用 ES6 class形式 完成单例模式\ntodo 使用 构造函数形式 完成单例模式",
    "date": "2023-09-01 06:23:23"
  },
  {
    "id": "blog:设计模式-序",
    "type": "blog",
    "content": "设计模式通常是一种编程思想，常见的设计模式是对常见开发模式的总结归纳。它如同算法并不局限于某一种单一的编程语言，只要你对它理解透彻，那你在任何语言中都可以随心所欲的使用。\n\n1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。\n\n「GoF设计模式」中将设计模式分成了三种创建型模式、结构型模式、行为型模式。\n\n创建型模式，主要描述如何创建一个模型的模式，例如工厂模式，单例模式等等。\n\n结构型模式，主要描述类和对象按照不同的模式组建成更大的结构，例如代理，桥接等等。\n\n行为型模型，主要描述类和对象之间的共同协作互助完成单一对象无法完成的任务，例如观察者，迭代器等等。\n\n一个合格的程序员应该熟练掌握二十三种设计模式，在你看到某个功能的时候应该不由自主的想到应该使用什么样的设计模式，当然如果现在你还不能很好的理解所有的设计模式，不要慌张，从现在开始了解它，熟悉它就可以，每个人都是从不了解到熟悉的。\n\n这个专栏将会带你入门设计模式，并且尽可能让你掌握二十三种设计模式。",
    "date": "2023-09-01 06:23:54"
  },
  {
    "id": "blog:设计模式-目录",
    "type": "blog",
    "content": "序\n[目录]()\n单例模式 - 使用闭包完成单例模式开发",
    "date": "2023-09-01 06:51:47"
  },
  {
    "id": "blog:exploration-on-object-order-in-javascript",
    "type": "blog",
    "content": "昨天的面试中出现了一个题目：\n\n将 对象  按照值的顺序排列。\n\n由于做开始他说的一个数组，说这个题的时候我以为是类数组对象，结果是是如上的对象，排序嘛，（不考虑时间复杂度和空间复杂度的话）基本上没什么难度， 但是一直有一个疑惑在脑中，Object 不是无序的吗？\n\n本文主要探讨不同的 Object 定义方式（或者说声明方式）是否影响”Object 顺序“，”Object 顺序“是什么样的，以及常见处理”Object顺序“的方式。\n\n首先再次之前我的认为是”对象是无序的，数组是有序的，如果处理对象的顺序的话，还是使用数组对象的方式“ 。\n\n在 ECMA-2623rdeditiondecember1999 中有提到：\n\n4.3.3 Object \nAn object is a member of the type Object. It is an unordered collection of properties each of which contains a primitive value, object, or function. A function stored in a property of an object is called a method.\n\n也就是在 ES3 中是 Objiect 是乱序的，但是在 ES6 中逐渐开始在 Object 的中开始添加 Object 部分放的顺序之说。\n\n不同浏览器在处理  时的解析顺序时不同的，在 Chrome 和 Opera 中遵循的是 ECMA-262 第五版本规范，而在 Firefox 和 Safari遵循的是 ECMA-262  第三版本规范。\n\n在通常情况下，如果要处理对象的排序，我建议使用数组处理，也就是将对象处理为  这样的的数组形式，按照数组排序，因为我还是觉得对象是无序的，尽管他是按照一定的顺序排序的，但为了避免在不同的浏览器中的排序不同还是将他作为数组处理比较好。\n参考文献\njs能够保证object属性的输出顺序吗？ - Jartto's blog\nDoes JavaScript guarantee object property order? - Stack Overflow\nECMA-2623rdeditiondecember1999",
    "date": "2023-08-18 17:47:53"
  },
  {
    "id": "blog:web-标准-javascript-手写-promise",
    "type": "blog",
    "content": "![[手写 Promise 2023-09-10 19.39.19.excalidraw]]\n\n参考文献\nPromise A+ 规范 中文版",
    "date": "2023-09-18 09:48:43"
  }
]